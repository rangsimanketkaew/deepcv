"""
Deep learning-based collective variables (DeepCV)
https://gitlab.uzh.ch/LuberGroup/deepcv

Info:
28/11/2020 : Rangsiman Ketkaew
"""

"""
Generate PLUMED input file using neural-network-based collective variable for metadynamics simulation
"""

import os
import argparse
import numpy as np
from src.utils import util
from datetime import datetime


class WritePlumed:
    def __init__(self, num_atoms: int, weight, bias, func_1: str, func_2: str, func_3: str, max_scale=None, leakyrelu_coeff=0.1, elu_coeff=0.1,
                 filename="plumed-NN.dat", colvar_file="COLVAR.log"):
        """Initialize class with a set of required parameters.
        Input vector will be multiplied by weights for each node. Bias will also be added.
        Activation function will be applied for each node. Available activation functions are as follow:

        linear: y = x
        binary: step(x)
        sigmoid: y = 1.0/(11.0+exp(-x))
        tanh: y = exp(x) - exp(-x) / exp(x) + exp(-x)
        relu: y = step(x)*x
        leakyrelu: y = a*step(-x) + step(x)*x
        elu: y = a*(exp(step(-x)) - 1) + step(x)*x

        Args:
            num_atoms (int): Number of atoms in the simulation system.
            weight (array): Trained neural network model.
            bias (array): Name of PLUMED input file.
            func_1 (str): Activation function of hidden layer 1.
            func_2 (str): Activation function of hidden layer 2.
            func_3 (str): Activation function of hidden layer 3 (encoded layer).
            leakyrely_coeff (int, float): Coefficient of LeakyReLU activation function. Defaults to 0.1.
            elu_coeff (int, float): Coefficient of ELU activation function. Defaults to 0.1.
            max_scale (int): Maximum value for normalization. Defaults to None.
            filename (str): Plumed file name. Defaults to "plumed-NN.dat".
            colvar_file (str): Name of collective variable file. Defaults to "COLVAR.log".
        """

        self.weight = weight
        self.bias = bias
        self.leakyrelu_coeff = leakyrelu_coeff
        act_func = {
            "linear": lambda v: f"(x{v:+.8f})",
            "binary": lambda v: f"step(x{v:+.8f})",
            "sigmoid": lambda v: f"1.0/(1.0+exp(-x{v:+.8f}))",
            "tanh": lambda v: f"exp(x{v:+.8f})-exp(-x{v:+.8f}))/(exp(x{v:+.8f})+exp(-x{v:+.8f})",
            "relu": lambda v: f"step(x{v:+.8f})*(x{v:+.8f})",
            "leakyrelu": lambda v: f"{self.leakyrelu_coeff}*step(-(x{v:+.8f}))+step(x{v:+.8f})*(x{v:+.8f})",
            "elu": lambda v: f"{self.leakyrelu_coeff}*(exp(step(-(x{v:+.8f})))-1)+step(x{v:+.8f})*(x{v:+.8f})"
        }
        self.func_1 = act_func[func_1.lower()]
        self.func_2 = act_func[func_2.lower()]
        self.func_3 = act_func[func_3.lower()]
        self.max_scale = max_scale
        self.filename = filename
        self.colvar_file = colvar_file
        self.num_feat = 0
        self.kw_1 = 'layer5'
        self.kw_2 = 'layer6'
        self.kw_3 = 'layer7'
        self.size_layer1 = self.weight[self.kw_1].shape[1]
        self.size_layer2 = self.weight[self.kw_2].shape[1]
        self.size_layer3 = self.weight[self.kw_3].shape[1]
        self.stride_input = 10
        self.stride_layer1 = 10
        self.stride_layer2 = 10
        self.stride_layer3 = 10
        self.stride_flush = 50

        self.f = open(self.filename, "w")
        self.f.write("# Deep learning-based collective variables for metadynamics simulation.\n")
        today = datetime.now().strftime("%b-%d-%y %H:%M:%S")
        self.f.write(f"# This file was generated by deepcv2plumed subroutine on {today}\n\n")
        self.f.write("# RESTART\n\n")
        self.f.write("UNITS LENGTH=A TIME=fs\n\n")
        self.num_atoms = num_atoms
        self.f.write(f"# Total number of atoms = {self.num_atoms}\n")
        # self.f.write(f"WHOLEMOLECULES ENTITY0=1-{self.num_atoms}\n\n")

        # Define input (features)
        self.f.write("# Distance\n")
        self.f.write("d1: DISTANCE ATOMS=2,1\n")
        self.f.write("d2: DISTANCE ATOMS=3,1\n")
        self.num_feat += 2
        for i in range(self.num_atoms - 3):
            self.f.write(f"d{i+3}: DISTANCE ATOMS={i+4},{i+1}\n")
            self.num_feat += 1
        self.f.write("# Angle (radian)\n")
        self.f.write("a1: ANGLE ATOMS=3,1,2\n")
        self.num_feat += 1
        for i in range(self.num_atoms - 3):
            self.f.write(f"a{i+2}: ANGLE ATOMS={i+4},{i+1},{i+2}\n")
            self.num_feat += 1
        self.f.write("# Torsional angle (radian)\n")
        for i in range(self.num_atoms - 3):
            self.f.write(f"t{i+1}: TORSION ATOMS={i+4},{i+1},{i+2},{i+3}\n")
            self.num_feat += 1
        self.f.write(f"\n# Total number of inputs = {self.num_feat}\n")
        arg = [f'd{j+1}' for j in range(self.num_atoms - 1)] \
                + [f'a{j+1}' for j in range(self.num_atoms - 2)] \
                + [f't{j+1}' for j in range(self.num_atoms - 3)]
        arg = ",".join(arg)
        self.f.write(f"PRINT FILE=input_plumed.log STRIDE={self.stride_input} ARG={arg}\n")

        self.f.write("\n# Neural network\n")
        #----------- LAYER 1 -----------#
        self.f.write("#===== Hidden layer 1 =====#\n")
        # Loop over nodes (neurons) in the present hidden layer
        for i in range(self.size_layer1):
            # Multiply input by weight
            self.f.write("COMBINE ...\n")
            self.f.write(f"\tLABEL=hl1_n{i+1}_mult\n")
            self.f.write(f"\tARG={arg}\n")
            weight = map(str, self.weight[self.kw_1][:,i])
            weight = ",".join(weight)
            self.f.write(f"\tCOEFFICIENTS={weight}\n")
            self.f.write(f"\tPOWERS={','.join(['1'] * self.num_feat)}\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... COMBINE\n")
        self.f.write("\n")
        for i in range(self.size_layer1):
            # Add bias and apply activation function
            self.f.write("MATHEVAL ...\n")
            self.f.write(f"\tLABEL=hl1_n{i+1}_out\n")
            self.f.write(f"\tARG=hl1_n{i+1}_mult\n")
            self.f.write(f"\tFUNC=({self.func_1(self.bias[self.kw_1][i])})\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... MATHEVAL\n")
        self.f.write(f"\nPRINT FILE=layer1.log STRIDE={self.stride_layer1} ARG={','.join([f'hl1_n{i+1}_out' for i in range(self.size_layer1)])}\n")

        #----------- LAYER 2 -----------#
        self.f.write("\n#===== Hidden layer 2 =====#\n")
        # Loop over nodes (neurons) in the present hidden layer
        for i in range(self.size_layer2):
            # Multiply input by weight
            self.f.write("COMBINE ...\n")
            self.f.write(f"\tLABEL=hl2_n{i+1}_mult\n")
            arg = [f'hl1_n{j+1}_out' for j in range(self.size_layer1)]
            arg = ",".join(arg)
            self.f.write(f"\tARG={arg}\n")
            weight = map(str, self.weight[self.kw_2][:,i])
            weight = ",".join(weight)
            self.f.write(f"\tCOEFFICIENTS={weight}\n")
            self.f.write(f"\tPOWERS={','.join(['1'] * self.size_layer1)}\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... COMBINE\n")
        self.f.write("\n")
        for i in range(self.size_layer2):
            # Add bias and apply activation function
            self.f.write("MATHEVAL ...\n")
            self.f.write(f"\tLABEL=hl2_n{i+1}_out\n")
            self.f.write(f"\tARG=hl2_n{i+1}_mult\n")
            self.f.write(f"\tFUNC=({self.func_2(self.bias[self.kw_2][i])})\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... MATHEVAL\n")
        self.f.write(f"\nPRINT FILE=layer2.log STRIDE={self.stride_layer2} ARG={','.join([f'hl2_n{i+1}_out' for i in range(self.size_layer2)])}\n")

        #----------- LAYER 3 -----------#
        self.f.write("\n#===== Hidden layer 3 =====#\n")
        # Loop over nodes (neurons) in the present hidden layer
        for i in range(self.size_layer3):
            # Multiply input by weight
            self.f.write("COMBINE ...\n")
            self.f.write(f"\tLABEL=hl3_n{i+1}_mult\n")
            arg = [f'hl2_n{j+1}_out' for j in range(self.size_layer2)]
            arg = ",".join(arg)
            self.f.write(f"\tARG={arg}\n")
            weight = map(str, self.weight[self.kw_3][:,i])
            weight = ",".join(weight)
            self.f.write(f"\tCOEFFICIENTS={weight}\n")
            self.f.write(f"\tPOWERS={','.join(['1'] * self.size_layer2)}\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... COMBINE\n")
        self.f.write("\n")
        for i in range(self.size_layer3):
            # Add bias and apply activation function
            self.f.write("MATHEVAL ...\n")
            self.f.write(f"\tLABEL=hl3_n{i+1}_out\n")
            self.f.write(f"\tARG=hl3_n{i+1}_mult\n")
            self.f.write(f"\tFUNC=({self.func_3(self.bias[self.kw_3][i])})\n")
            self.f.write("\tPERIODIC=NO\n")
            self.f.write("... MATHEVAL\n")
        self.f.write(f"\nPRINT FILE=layer3.log STRIDE={self.stride_layer3} ARG={','.join([f'hl3_n{i+1}_out' for i in range(self.size_layer3)])}\n")

        # Update PLUMED output files
        self.f.write(f"\n# Update all files every {self.stride_flush} steps\n")
        self.f.write(f"FLUSH STRIDE={self.stride_flush}\n")

        # Save/Print CVs
        self.colvar = [f'hl3_n{j+1}_out' for j in range(self.size_layer3)]
        colvar = ",".join(self.colvar)
        self.f.write(f"\nPRINT ARG={colvar} STRIDE=1 FILE={self.colvar_file}\n")
        self.f.write(f"\n# You can use the following variables as CVs: {colvar}\n")
        self.f.close()

    def write_MetaD(self, metad_label="metad", sigma=0.05, height=2.0, pace=50, well_tempered=True, temp=300, bias_factor=25,
                    hill_name="HILLS", bias_name="bias.log", stride_metad=1):
        """Write input for well-tempered metadynamics simulation

        Args:
            metad_label (str, optional): Label of metadynamics object. Defaults to "metad".
            sigma (float, optional): Width of Gaussian potential. Defaults to 0.05.
            height (float, optional): Height of Gaussian potential. Defaults to 2.0.
            pace (int, optional): Frequency of Gaussian potential deposition. Defaults to 50.
            well_tempered (bool, optional): Turn on/off well-tempered metadynamics. Defaults to True.
            temp (int, optional): Temperature (in Kelvin). Defaults to 300.
            bias_factor (int, optional): Factor of well-tempered bias. Defaults to 25.
            hill_name (str, optional): Name of Gaussian HILLS file. Defaults to "HILLS".
            bias_name (str, optional): Name of bias output. Defaults to "bias.log".
            stride_metad (str, optional): Value of stride parameter for printing metadynamics bias. Defaults to 1.
        """
        self.metad_label = metad_label
        self.sigma = sigma
        self.height = height
        self.pace = pace
        self.well_tempered = well_tempered
        self.temp = temp
        self.bias_factor = bias_factor
        self.hill_name = hill_name
        self.bias_name = bias_name
        self.stride_metad = stride_metad

        # Metadynamics input
        self.f = open(self.filename, "a")
        self.f.write("\nMETAD ...\n")
        self.f.write("\tLABEL=metad\n")
        colvar = ",".join(self.colvar)
        self.f.write(f"\tARG={colvar}\n")
        self.f.write(f"\tSIGMA={','.join([str(self.sigma)] * len(self.colvar))}\n")
        self.f.write(f"\tHEIGHT={self.height}\n")
        self.f.write(f"\tPACE={self.pace}\n")
        if self.well_tempered:
            self.f.write(f"\tTEMP={self.temp}\n")
            self.f.write(f"\tBIASFACTOR={self.bias_factor}\n")
        self.f.write(f"\tFILE={self.hill_name}\n")
        self.f.write(f"... METAD\n")
        self.f.write(f"\nPRINT ARG={colvar},{self.metad_label}.bias FILE={self.bias_name} STRIDE={self.stride_metad}\n\n")
        self.f.close()


if __name__ == "__main__":
    info = ("Generate PLUMED input file (.dat) from neural network model (weights and biases) trained by DeepCV.")
    parser = argparse.ArgumentParser(description=info)
    parser.add_argument(
        "--input", "-i", metavar="INPUT", type=str, required=True,
        help="Input file (.json) that you used for training a model. \
            The input file must contain either absolute or relative path \
            of the directory in which the weight and bias NumPy's compresses file format (.npz) stored")
    parser.add_argument(
        "--num-atoms", "-n", metavar="N", type=int, required=True,
        help="Number of atoms in the simulation system. \
            The system should be the same kind of with which the model is trained")
    parser.add_argument(
        "--file-name", "-o", dest="filename", metavar="FILENAME", type=str, default="plumed_NN.dat", 
        help="Name of plumed input file (.dat). Default to 'plumed_NN.dat'")

    args = parser.parse_args()

    #------- Read input -------#
    if not os.path.isfile(args.input): exit(f'Error: No such file "{args.input}"')
    json = util.load_json(args.input)
    func_1 = json["network"]["func_1"]
    func_2 = json["network"]["func_2"]
    func_3 = json["network"]["func_3"]
    folder = json["output"]["out_dir"]
    weight = json["output"]["out_weights_npz"]
    bias = json["output"]["out_biases_npz"]
    max_scale = json["dataset"]["max_scale"]
    weight = folder + "/" + weight
    bias = folder + "/" + bias
    if not os.path.isfile(weight): exit(f'Error: No such file "{weight}"')
    if not os.path.isfile(bias): exit(f'Error: No such file "{bias}"')

    #------- Check file -------#
    weight = np.load(weight)
    bias = np.load(bias)

    #------- Start writing -------#
    p = WritePlumed(args.num_atoms, weight, bias, func_1, func_2, func_3, max_scale=max_scale, filename=args.filename)
    p.write_MetaD()
    print(f">>> Plumed data have been successfully written to '{os.path.abspath(args.filename)}'")
    print(">>> In order to run metadynamics using CP2K & PLUMED, specify the following input deck in CP2K input:\n")
    cp2k = f"# Import PLUMED input file\n\
&MOTION\n\
    &FREE_ENERGY\n\
        &METADYN\n\
            USE_PLUMED .TRUE.\n\
            PLUMED_INPUT_FILE {os.path.abspath(args.filename)}\n\
        &END METADYN\n\
    &END FREE_ENERGY\n\
%END MOTION\n"
    print(cp2k)
